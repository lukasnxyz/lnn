import numpy as np

class Tensor:
	def __init__(self, data, _children=()):
		assert(isinstance(data, np.ndarray))
		self.data = data
		self.grad = np.zeros_like(data)
		self._prev = set(_children)
		self._backward = lambda: None

	def __repr__(self):
		return f"Tensor(data: {self.data}, grad: {self.grad})"

	def add(self, other):
		other = other if isinstance(other, Tensor) else Tensor(other)
		out = Tensor(self.data + other.data, {self, other})

		def _backward():
			self.grad += 1.0 * out.grad
			other.grad += 1.0 * out.grad
		out._backward = _backward

		return out

	def mul(self, other):
		other = other if isinstance(other, Tensor) else Tensor(other)
		out = Tensor(self.data * other.data, {self, other})

		def _backward():
			print(type(out.grad))
			self.grad += other.data * out.grad
			other.grad += self.data * out.grad
		out._backward = _backward

		return out

	def backward(self):
		topo = []
		visited = set()

		def build_topo(v):
			if v not in visited:
				visited.add(v)
				for child in v._prev:
						build_topo(child)
				topo.append(v)

		build_topo(self)

		self.grad = 1.0

		for node in reversed(topo):
			node._backward()

class Function:
	def apply(self, *tensor: Tensor, backward=lambda: None):
		tensor._backward = backward

class Add(Function):
	def forward(self, x, y):
		out = Tensor(x.data + y.data, {x, y}) # data, children
		self.apply()
		return out

	def _backward():

def main():
	a = Tensor(np.eye(2))
	b = Tensor(np.array([[1.0, 4.0], [3.0, 7.0]], dtype=np.float32))

	c = a.mul(b)
	c.backward()
	print(c)

if __name__ == "__main__":
	main()
